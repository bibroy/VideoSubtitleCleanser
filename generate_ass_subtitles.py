#!/usr/bin/env python
"""
Generate ASS subtitle files from WebVTT or SRT files.
ASS format provides complete control over subtitle styling and positioning.
"""

import os
import re
import sys
import pysrt
from datetime import timedelta

def convert_to_ass(input_file, output_ass, optimize_positions=True, font_style=None):
    """
    Convert subtitle file (WebVTT or SRT) to ASS format with proper styling
    
    Args:
        input_file: Path to the input subtitle file (WebVTT or SRT)
        output_ass: Path to the output ASS file
        optimize_positions: If True, position cue4 at the top to avoid overlaying text
        font_style: Dictionary with font styling options:
            - font_name: Font family name (default: Arial)
            - font_size: Font size in points (default: 24)
            - primary_color: Text color in BBGGRR format (default: &H00FFFFFF - white)
            - outline_color: Outline color in BBGGRR format (default: &H00000000 - black)
            - back_color: Background color in BBGGRR format (default: &H80000000 - semi-transparent black)
            - bold: Bold text (0=off, 1=on, default: 0)
            - italic: Italic text (0=off, 1=on, default: 0)
            - outline: Outline thickness (default: 2)
            - shadow: Shadow depth (default: 3)
    """
    # Set default font style if not provided
    if font_style is None:
        font_style = {}
    
    # Apply defaults for any missing style options
    font_name = font_style.get('font_name', 'Arial')
    font_size = font_style.get('font_size', 24)
    primary_color = font_style.get('primary_color', '&H00FFFFFF')  # White
    outline_color = font_style.get('outline_color', '&H00000000')  # Black
    back_color = font_style.get('back_color', '&H80000000')  # Semi-transparent black
    bold = font_style.get('bold', 0)
    italic = font_style.get('italic', 0)
    outline = font_style.get('outline', 2)
    shadow = font_style.get('shadow', 3)
    print(f"Converting {input_file} to ASS format: {output_ass}")
    
    # Determine input format
    input_ext = os.path.splitext(input_file)[1].lower()
    
    # Load subtitles based on format
    if input_ext == '.vtt':
        subs = load_vtt(input_file)
    elif input_ext == '.srt':
        subs = pysrt.open(input_file)
    else:
        print(f"Unsupported input format: {input_ext}")
        return False
    
    # Create ASS file
    try:
        with open(output_ass, 'w', encoding='utf-8') as f:
            # Write ASS header
            f.write("[Script Info]\n")
            f.write("; Script generated by VideoSubtitleCleanser\n")
            f.write("ScriptType: v4.00+\n")
            f.write("PlayResX: 1280\n")
            f.write("PlayResY: 720\n")
            f.write("Timer: 100.0000\n")
            f.write("WrapStyle: 0\n\n")
            
            # Write style definitions
            f.write("[V4+ Styles]\n")
            f.write("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n")
            
            # Secondary color (for karaoke effects, not typically used)
            secondary_color = "&H000000FF"  # Blue
            
            # Default style (bottom center)
            default_style = f"Style: Default,{font_name},{font_size},{primary_color},{secondary_color},{outline_color},{back_color},{bold},{italic},0,0,100,100,0,0,1,{outline},{shadow},2,10,10,10,1\n"
            f.write(default_style)
            
            # Top style (for subtitles that need to be at the top)
            top_style = f"Style: Top,{font_name},{font_size},{primary_color},{secondary_color},{outline_color},{back_color},{bold},{italic},0,0,100,100,0,0,1,{outline},{shadow},8,10,10,10,1\n\n"
            f.write(top_style)
            
            # Write events section
            f.write("[Events]\n")
            f.write("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")
            
            # Write subtitle entries
            for i, sub in enumerate(subs):
                # Convert timestamps to ASS format (h:mm:ss.cc)
                start_time = format_time_ass(sub.start)
                end_time = format_time_ass(sub.end)
                
                # Process text
                text = sub.text
                
                # Remove existing formatting tags
                text = re.sub(r'</?[a-z][^>]*>', '', text)
                
                # Handle speaker identification if present
                if '[' in text and ']' in text:
                    text = re.sub(r'\[(.*?)\]', r'{\b1}\1{\b0}: ', text)
                
                # Determine style based on position optimization
                style = "Default"
                if optimize_positions and i == 3:  # cue4 (0-indexed)
                    style = "Top"
                
                # Write ASS entry
                f.write(f"Dialogue: 0,{start_time},{end_time},{style},,0,0,0,,{text}\n")
        
        print(f"Conversion complete. ASS file saved to {output_ass}")
        return True
    
    except Exception as e:
        print(f"Error creating ASS file: {e}")
        return False

def load_vtt(vtt_file):
    """Load WebVTT file and convert to pysrt compatible format"""
    try:
        with open(vtt_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Skip the WEBVTT header
        if content.startswith('WEBVTT'):
            content = content.split('\n\n', 1)[1] if '\n\n' in content else content
        
        # Convert to SRT format in memory
        srt_content = ''
        cue_count = 1
        
        # Split into cues
        cues = re.split(r'\n\n+', content)
        
        for cue in cues:
            lines = cue.strip().split('\n')
            if len(lines) < 2:
                continue
            
            # Extract timestamp line
            timestamp_line = None
            for line in lines:
                if '-->' in line:
                    timestamp_line = line
                    break
            
            if not timestamp_line:
                continue
            
            # Parse timestamp
            timestamp = timestamp_line.strip()
            # Convert WebVTT format (00:00:00.000) to SRT format (00:00:00,000)
            timestamp = timestamp.replace('.', ',')
            # Remove positioning attributes if present
            timestamp = re.sub(r' align:[^>]*', '', timestamp)
            timestamp = re.sub(r' line:[^>]*', '', timestamp)
            timestamp = re.sub(r' position:[^>]*', '', timestamp)
            
            # Get text lines (everything after the timestamp line)
            text_lines = []
            text_started = False
            for line in lines:
                if text_started:
                    text_lines.append(line)
                elif '-->' in line:
                    text_started = True
            
            # Join text lines
            text = '\n'.join(text_lines)
            
            # Add to SRT content
            srt_content += f"{cue_count}\n{timestamp}\n{text}\n\n"
            cue_count += 1
        
        # Create a temporary SRT file
        temp_srt = vtt_file + '.temp.srt'
        with open(temp_srt, 'w', encoding='utf-8') as f:
            f.write(srt_content)
        
        # Load with pysrt
        subs = pysrt.open(temp_srt)
        
        # Remove temporary file
        os.remove(temp_srt)
        
        return subs
    
    except Exception as e:
        print(f"Error loading VTT file: {e}")
        return None

def format_time_ass(time_obj):
    """Convert pysrt time object to ASS time format (h:mm:ss.cc)"""
    hours = time_obj.hours
    minutes = time_obj.minutes
    seconds = time_obj.seconds
    milliseconds = time_obj.milliseconds
    
    # Convert to centiseconds (ASS format uses centiseconds)
    centiseconds = milliseconds // 10
    
    return f"{hours}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}"

def process_subtitle_file(input_file, output_base=None, font_style=None):
    """
    Process a subtitle file and generate ASS format
    
    Args:
        input_file: Path to the input subtitle file
        output_base: Base path for the output file (without extension)
        font_style: Dictionary with font styling options
    """
    if not os.path.exists(input_file):
        print(f"Error: Input file does not exist: {input_file}")
        return False
    
    # Determine output base name if not provided
    if output_base is None:
        output_base = os.path.splitext(input_file)[0]
    
    # Generate ASS file
    output_ass = f"{output_base}.ass"
    convert_to_ass(input_file, output_ass, optimize_positions=True, font_style=font_style)
    
    print(f"\nASS subtitle file created: {output_ass}")
    print("\nThis format provides:")
    print("- Complete styling control")
    print("- Precise positioning (cue4 at top, others at bottom)")
    print("- Excellent compatibility with PotPlayer, MPC-HC, and MPV")
    
    # Print the font style used
    if font_style:
        print("\nCustom font style applied:")
        for key, value in font_style.items():
            print(f"- {key}: {value}")
    
    return True

if __name__ == "__main__":
    import argparse
    
    # Create argument parser
    parser = argparse.ArgumentParser(description="Generate ASS subtitle files with custom styling")
    
    # Required arguments
    parser.add_argument("input", help="Path to the input subtitle file (WebVTT or SRT)")
    parser.add_argument("output", help="Base path for the output file (without extension)")
    
    # Font style arguments
    parser.add_argument("--font-name", default="Arial", help="Font family name (default: Arial)")
    parser.add_argument("--font-size", type=int, default=24, help="Font size in points (default: 24)")
    parser.add_argument("--primary-color", default="&H00FFFFFF", help="Text color in ASS format (default: &H00FFFFFF - white)")
    parser.add_argument("--outline-color", default="&H00000000", help="Outline color in ASS format (default: &H00000000 - black)")
    parser.add_argument("--back-color", default="&H80000000", help="Background color in ASS format (default: &H80000000 - semi-transparent black)")
    parser.add_argument("--bold", type=int, choices=[0, 1], default=0, help="Bold text (0=off, 1=on, default: 0)")
    parser.add_argument("--italic", type=int, choices=[0, 1], default=0, help="Italic text (0=off, 1=on, default: 0)")
    parser.add_argument("--outline", type=int, default=2, help="Outline thickness (default: 2)")
    parser.add_argument("--shadow", type=int, default=3, help="Shadow depth (default: 3)")
    
    # Parse arguments
    args = parser.parse_args()
    
    # Create font style dictionary from arguments
    font_style = {
        'font_name': args.font_name,
        'font_size': args.font_size,
        'primary_color': args.primary_color,
        'outline_color': args.outline_color,
        'back_color': args.back_color,
        'bold': args.bold,
        'italic': args.italic,
        'outline': args.outline,
        'shadow': args.shadow
    }
    
    # Process subtitle file with custom font style
    process_subtitle_file(args.input, args.output, font_style=font_style)
